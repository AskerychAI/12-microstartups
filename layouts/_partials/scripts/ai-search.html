{{/* AI-powered hybrid search script */}}
{{- if site.Params.search.ai.enable | default false -}}
<script>
(function() {
  'use strict';

  const AI_SEARCH_ENABLED = {{ site.Params.search.ai.enable | default false }};
  const EMBEDDINGS_MODEL = "{{ site.Params.search.ai.model | default "Xenova/all-MiniLM-L6-v2" }}";
  const EMBEDDINGS_URL = '/embeddings.json';

  let embeddingsData = null;
  let embeddingsModel = null;
  let modelLoading = false;

  // Load embeddings data
  async function loadEmbeddingsData() {
    if (embeddingsData) return embeddingsData;
    try {
      const response = await fetch(EMBEDDINGS_URL);
      if (!response.ok) return null;
      embeddingsData = await response.json();
      return embeddingsData;
    } catch (error) {
      console.warn('Failed to load embeddings:', error);
      return null;
    }
  }

  // Load transformers.js model (lazy)
  async function loadEmbeddingsModel() {
    if (embeddingsModel) return embeddingsModel;
    if (modelLoading) {
      return new Promise((resolve) => {
        const check = setInterval(() => {
          if (embeddingsModel) {
            clearInterval(check);
            resolve(embeddingsModel);
          }
        }, 100);
      });
    }

    modelLoading = true;
    try {
      // Load transformers.js from CDN
      if (!window.pipeline) {
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }

      const { pipeline } = window;
      embeddingsModel = await pipeline('feature-extraction', EMBEDDINGS_MODEL, {
        quantized: true,
        revision: 'main'
      });
      
      modelLoading = false;
      return embeddingsModel;
    } catch (error) {
      modelLoading = false;
      console.error('Failed to load model:', error);
      return null;
    }
  }

  // Cosine similarity
  function cosineSimilarity(vecA, vecB) {
    if (vecA.length !== vecB.length) return 0;
    let dot = 0, normA = 0, normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dot += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    const denom = Math.sqrt(normA) * Math.sqrt(normB);
    return denom === 0 ? 0 : dot / denom;
  }

  // Semantic search
  async function semanticSearch(query, limit = 10) {
    if (!embeddingsData || !embeddingsModel) return [];
    
    try {
      const output = await embeddingsModel(query, { pooling: 'mean', normalize: true });
      const queryVec = Array.from(output.data);
      
      const similarities = [];
      for (const [url, doc] of Object.entries(embeddingsData)) {
        const sim = cosineSimilarity(queryVec, doc.embedding);
        similarities.push({
          url: doc.url,
          title: doc.title,
          content: doc.content.substring(0, 200),
          similarity: sim
        });
      }
      
      similarities.sort((a, b) => b.similarity - a.similarity);
      return similarities.slice(0, limit);
    } catch (error) {
      console.error('Semantic search error:', error);
      return [];
    }
  }

  // Enhance existing search results with semantic results
  async function enhanceSearchResults(query) {
    if (!AI_SEARCH_ENABLED || !query || query.length < 2) return;

    // Get active search element
    const wrappers = Array.from(document.querySelectorAll('.hextra-search-wrapper')).filter(el => el.clientHeight > 0);
    if (wrappers.length === 0) return;
    
    const wrapper = wrappers[0];
    const resultsElement = wrapper.querySelector('.hextra-search-results');
    if (!resultsElement) return;

    // Load data and model if needed
    if (!embeddingsData) {
      await loadEmbeddingsData();
      if (!embeddingsData) return;
    }

    // Load model (lazy)
    if (!embeddingsModel && !modelLoading) {
      await loadEmbeddingsModel();
      if (!embeddingsModel) return;
    }

    // Perform semantic search
    const semanticResults = await semanticSearch(query, 5);
    if (semanticResults.length === 0) return;

    // Get existing FlexSearch results from DOM
    const existingResults = new Set();
    Array.from(resultsElement.querySelectorAll('a')).forEach(a => {
      existingResults.add(a.getAttribute('href'));
    });

    // Add semantic results that aren't already shown
    let added = false;
    semanticResults.forEach(result => {
      if (!existingResults.has(result.url) && result.similarity > 0.3) {
        // Add semantic result to DOM
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = result.url;
        a.className = 'hextra-search-result-semantic';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'hextra-search-title';
        titleDiv.textContent = result.title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'hextra-search-excerpt';
        contentDiv.textContent = result.content;
        
        a.appendChild(titleDiv);
        a.appendChild(contentDiv);
        li.appendChild(a);
        
        // Insert after existing results
        resultsElement.appendChild(li);
        added = true;
      }
    });

    if (added) {
      // Update result count
      const count = resultsElement.querySelectorAll('li').length;
      resultsElement.dataset.count = count;
    }
  }

  // Hook into search input events
  function initAIEnhancement() {
    const inputs = document.querySelectorAll('.hextra-search-input');
    inputs.forEach(input => {
      let enhanceTimeout;
      const originalHandler = input.oninput;
      
      input.addEventListener('input', function(e) {
        const query = e.target.value;
        
        // Clear previous timeout
        clearTimeout(enhanceTimeout);
        
        // Wait a bit after user stops typing, then enhance
        if (query && query.length >= 2) {
          enhanceTimeout = setTimeout(() => {
            enhanceSearchResults(query);
          }, 800); // Wait 800ms after last keystroke
        }
      });
    });
  }

  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initAIEnhancement, 2000); // Wait for FlexSearch to initialize
    });
  } else {
    setTimeout(initAIEnhancement, 2000);
  }

})();
</script>
{{- end -}}
